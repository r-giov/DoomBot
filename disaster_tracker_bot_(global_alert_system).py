# -*- coding: utf-8 -*-
"""Disaster Tracker Bot (Global Alert System)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M4OgD1ZHGHMAM5aaPaCXSXLoWLSd480H
"""

# This is a more advanced bot that fetches real data.
# It gets the latest significant earthquakes from the USGS (U.S. Geological Survey).
# You will also need the 'requests' library. To install it, run:
# pip install requests

import logging
import requests  # The library used to fetch data from the internet
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler, CallbackQueryHandler
import asyncio
import os # Import the os module to access environment variables

# --- CONFIGURATION ---
# The bot token is now expected to be an environment variable for security.
TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
# The port number is provided by the hosting service.
PORT = int(os.environ.get('PORT', 8443))
# ---------------------

# --- API ENDPOINTS ---
EONET_API_URL = "https://eonet.gsfc.nasa.gov/api/v3/events"
USGS_API_URL = "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_day.geojson"
NWS_API_URL = "https://api.weather.gov/alerts/active" # For Tsunami alerts
TSUNAMI_EVENT_TYPES = ["Tsunami Warning", "Tsunami Watch", "Tsunami Advisory"]


# --- GEOGRAPHICAL FILTERING (CARIBBEAN) ---
CARIBBEAN_BOUNDS = {"min_lat": 8, "max_lat": 28, "min_lon": -90, "max_lon": -58}
CARIBBEAN_KEYWORDS = [
    "jamaica", "cuba", "haiti", "dominican republic", "puerto rico",
    "bahamas", "caribbean", "antigua", "barbuda", "barbados", "dominica",
    "grenada", "st. kitts", "nevis", "st. lucia", "st. vincent", "trinidad", "tobago",
    "u.s. virgin islands", "british virgin islands", "guadeloupe", "martinique"
]

def is_in_caribbean(lat, lon):
    """Checks if coordinates are within the Caribbean bounding box."""
    if lat is None or lon is None:
        return False
    return CARIBBEAN_BOUNDS["min_lat"] <= lat <= CARIBBEAN_BOUNDS["max_lat"] and \
           CARIBBEAN_BOUNDS["min_lon"] <= lon <= CARIBBEAN_BOUNDS["max_lon"]

def text_mentions_caribbean(text):
    """Checks if a string contains Caribbean-related keywords."""
    if not text:
        return False
    lower_text = text.lower()
    return any(keyword in lower_text for keyword in CARIBBEAN_KEYWORDS)


# --- DATA STORAGE (IN-MEMORY) ---
# For a real-world application, you'd use a database to ensure data persists.
user_subscriptions = {
    "earthquakes": set(),
    "wildfires": set(),
    "storms": set(),
    "volcanoes": set(),
    "tsunamis": set(),
    "caribbean": set()  # Special category for regional alerts
}
seen_event_ids = set()


# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# --- HELPER FUNCTIONS FOR FETCHING DATA ---

async def fetch_eonet_events(category, limit=5, days=2):
    """Fetches events from NASA's EONET API."""
    params = {'category': category, 'limit': limit, 'days': days, 'status': 'open'}
    try:
        response = requests.get(EONET_API_URL, params=params)
        response.raise_for_status()
        return response.json().get('events', [])
    except requests.exceptions.RequestException as e:
        logging.error(f"EONET API request failed for category {category}: {e}")
        return []

async def fetch_usgs_earthquakes(limit=5):
    """Fetches significant earthquake data from the USGS API."""
    try:
        response = requests.get(USGS_API_URL)
        response.raise_for_status()
        return response.json().get('features', [])
    except requests.exceptions.RequestException as e:
        logging.error(f"USGS API request failed: {e}")
        return []

async def fetch_nws_tsunami_alerts():
    """Fetches active tsunami alerts from the NWS API."""
    headers = {"User-Agent": "GlobalDisasterAlertBot/1.0 (disasterbot@example.com)"}
    params = {"event": ",".join(TSUNAMI_EVENT_TYPES)}
    try:
        response = requests.get(NWS_API_URL, params=params, headers=headers)
        response.raise_for_status()
        return response.json().get('features', [])
    except requests.exceptions.RequestException as e:
        logging.error(f"NWS API request failed: {e}")
        return []

# --- COMMAND HANDLERS ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Sends a welcome message with instructions."""
    welcome_text = (
        "Welcome to the Global Disaster Alert System!\n\n"
        "I monitor global events in near real-time and can send you alerts for specific event types or regions.\n\n"
        "**Key Features:**\n"
        "- `/subscribe`: Choose which alerts you want to receive. Now includes **Tsunamis** and a special **Caribbean** region filter!\n"
        "- `/unsubscribe`: Stop receiving alerts.\n\n"
        "**Manual Data Requests:**\n"
        "/earthquakes | /wildfires | /storms | /volcanoes | /tsunamis\n"
        "/caribbean - Get a summary of all recent events in the Caribbean."
    )
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=welcome_text,
        parse_mode='Markdown'
    )

# ... (get_earthquakes and other manual fetchers remain mostly the same)
async def get_earthquakes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Manually fetches and formats earthquake data."""
    await context.bot.send_message(chat_id=update.effective_chat.id, text="Fetching latest earthquake data...")
    earthquakes = await fetch_usgs_earthquakes()
    if not earthquakes:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="No significant earthquakes found recently.")
        return

    message = " M4.5+ Recent Earthquakes:\n\n"
    for eq in earthquakes[:5]:
        props = eq.get('properties', {})
        mag = props.get('mag', 'N/A')
        place = props.get('place', 'Unknown')
        url = props.get('url', '#')
        message += f"Magnitude: {mag}\nLocation: {place}\n<a href='{url}'>More Info</a>\n\n"

    await context.bot.send_message(chat_id=update.effective_chat.id, text=message, parse_mode='HTML', disable_web_page_preview=True)


async def get_eonet_data(update: Update, context: ContextTypes.DEFAULT_TYPE, category: str, category_name: str):
    """Generic function to fetch and display EONET data."""
    await context.bot.send_message(chat_id=update.effective_chat.id, text=f"Fetching latest {category_name} data...")
    events = await fetch_eonet_events(category)
    if not events:
        await context.bot.send_message(chat_id=update.effective_chat.id, text=f"No significant open events found for {category_name}.")
        return

    message = f" Major Active {category_name.capitalize()}:\n\n"
    for event in events:
        title = event.get('title', 'N/A')
        link = event.get('link', '#')
        message += f"Event: {title}\n<a href='{link}'>More Info (NASA)</a>\n\n"

    await context.bot.send_message(chat_id=update.effective_chat.id, text=message, parse_mode='HTML', disable_web_page_preview=True)

async def get_wildfires(update: Update, context: ContextTypes.DEFAULT_TYPE): await get_eonet_data(update, context, "wildfires", "wildfires")
async def get_storms(update: Update, context: ContextTypes.DEFAULT_TYPE): await get_eonet_data(update, context, "severeStorms", "severe storms")
async def get_volcanoes(update: Update, context: ContextTypes.DEFAULT_TYPE): await get_eonet_data(update, context, "volcanoes", "volcanoes")

async def get_tsunamis(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Manually fetches and formats tsunami alerts."""
    await context.bot.send_message(chat_id=update.effective_chat.id, text="Fetching active tsunami alerts...")
    alerts = await fetch_nws_tsunami_alerts()
    if not alerts:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="No active tsunami warnings, watches, or advisories found.")
        return

    message = " Active Tsunami Alerts:\n\n"
    for alert in alerts[:5]:
        props = alert.get('properties', {})
        headline = props.get('headline', 'No headline')
        area = props.get('areaDesc', 'Unknown area')
        message += f"Alert: {headline}\nAffected Area: {area}\n\n"

    await context.bot.send_message(chat_id=update.effective_chat.id, text=message, parse_mode='HTML')

async def get_caribbean_summary(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fetches a summary of all recent disaster events in the Caribbean."""
    await context.bot.send_message(chat_id=update.effective_chat.id, text="Fetching summary of recent events in the Caribbean...")
    # This is a simplified summary. A full implementation would be more complex.
    message = " Caribbean Region Event Summary:\n\n"
    found_event = False

    # Earthquakes
    eqs = await fetch_usgs_earthquakes(limit=10)
    for eq in eqs:
        lon, lat, _ = eq.get('geometry', {}).get('coordinates', [None, None, None])
        if is_in_caribbean(lat, lon):
            place = eq.get('properties', {}).get('place', 'Unknown')
            message += f"• [Earthquake] {place}\n"
            found_event = True

    # EONET Events
    for cat in ["severeStorms", "wildfires", "volcanoes"]:
        events = await fetch_eonet_events(cat, limit=10)
        for event in events:
             geom = event.get('geometry', [{}])[0]
             if geom and geom.get('type') == 'Point':
                lon, lat = geom.get('coordinates', [None, None])
                if is_in_caribbean(lat, lon):
                    title = event.get('title', 'Unknown Event')
                    message += f"• [{cat}] {title}\n"
                    found_event = True

    if not found_event:
        message = "No significant recent disaster activity detected in the Caribbean region."

    await context.bot.send_message(chat_id=update.effective_chat.id, text=message)


# --- SUBSCRIPTION MANAGEMENT ---
# ... (This section remains the same as before, it will automatically handle the new categories)
def get_subscription_keyboard(chat_id: int, action: str):
    """Creates an inline keyboard for subscribing or unsubscribing."""
    keyboard = []
    for category in user_subscriptions.keys():
        is_subscribed = chat_id in user_subscriptions[category]
        if (action == "subscribe" and not is_subscribed) or \
           (action == "unsubscribe" and is_subscribed):
            keyboard.append([InlineKeyboardButton(f"{category.capitalize()}", callback_data=f"{action}_{category}")])
    return InlineKeyboardMarkup(keyboard)

async def subscribe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Sends a message with subscription options."""
    chat_id = update.effective_chat.id
    keyboard = get_subscription_keyboard(chat_id, "subscribe")
    if not keyboard.inline_keyboard:
        await update.message.reply_text("You are already subscribed to all available alerts.")
    else:
        await update.message.reply_text("Choose which alerts to subscribe to:", reply_markup=keyboard)


async def unsubscribe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Sends a message with unsubscription options."""
    chat_id = update.effective_chat.id
    keyboard = get_subscription_keyboard(chat_id, "unsubscribe")
    if not keyboard.inline_keyboard:
        await update.message.reply_text("You are not subscribed to any alerts.")
    else:
        await update.message.reply_text("Choose which alerts to unsubscribe from:", reply_markup=keyboard)

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Parses the CallbackQuery and updates the subscription."""
    query = update.callback_query
    await query.answer()

    action, category = query.data.split('_')
    chat_id = query.effective_chat.id

    if action == "subscribe":
        user_subscriptions[category].add(chat_id)
        await query.edit_message_text(text=f"Subscribed to {category} alerts!")
    elif action == "unsubscribe":
        user_subscriptions[category].discard(chat_id)
        await query.edit_message_text(text=f"Unsubscribed from {category} alerts.")


# --- PROACTIVE ALERTING JOB ---

async def check_for_alerts(context: ContextTypes.DEFAULT_TYPE):
    """The core function that checks for new events and sends alerts."""
    logging.info("Checking for new disaster alerts...")

    # 1. Check for Earthquakes (USGS)
    eq_events = await fetch_usgs_earthquakes(limit=10)
    for event in eq_events:
        event_id = event.get('id')
        if event_id and event_id not in seen_event_ids:
            seen_event_ids.add(event_id)
            props = event.get('properties', {})
            mag = props.get('mag', 'N/A')
            place = props.get('place', 'Unknown')
            url = props.get('url', '#')
            lon, lat, _ = event.get('geometry', {}).get('coordinates', [None, None, None])
            message = (f"NEW EARTHQUAKE ALERT\n\nMagnitude: {mag}\nLocation: {place}\n<a href='{url}'>More Info</a>")

            # Send to general subscribers
            for chat_id in user_subscriptions["earthquakes"]:
                await context.bot.send_message(chat_id, message, parse_mode='HTML', disable_web_page_preview=True)
            # Send to Caribbean subscribers if relevant
            if is_in_caribbean(lat, lon):
                for chat_id in user_subscriptions["caribbean"]:
                    await context.bot.send_message(chat_id, f"[CARIBBEAN REGION] {message}", parse_mode='HTML', disable_web_page_preview=True)

    # 2. Check for EONET Events (Wildfires, Storms, Volcanoes)
    for category in ["wildfires", "severeStorms", "volcanoes"]:
        sub_key = "storms" if category == "severeStorms" else category
        events = await fetch_eonet_events(category, limit=10, days=2)
        for event in events:
            event_id = event.get('id')
            if event_id and event_id not in seen_event_ids:
                seen_event_ids.add(event_id)
                title = event.get('title', 'N/A')
                link = event.get('link', '#')
                message = (f"NEW {sub_key.upper()} ALERT\n\nEvent: {title}\n<a href='{link}'>More Info (NASA)</a>")

                # Send to general subscribers
                for chat_id in user_subscriptions[sub_key]:
                    await context.bot.send_message(chat_id, message, parse_mode='HTML', disable_web_page_preview=True)

                # Send to Caribbean subscribers if relevant
                geom = event.get('geometry', [{}])[0]
                if geom and geom.get('type') == 'Point':
                    lon, lat = geom.get('coordinates', [None, None])
                    if is_in_caribbean(lat, lon):
                        for chat_id in user_subscriptions["caribbean"]:
                            await context.bot.send_message(chat_id, f"[CARIBBEAN REGION] {message}", parse_mode='HTML', disable_web_page_preview=True)
        await asyncio.sleep(1)

    # 3. Check for Tsunamis (NWS)
    tsunami_alerts = await fetch_nws_tsunami_alerts()
    for alert in tsunami_alerts:
        event_id = alert.get('id')
        if event_id and event_id not in seen_event_ids:
            seen_event_ids.add(event_id)
            props = alert.get('properties', {})
            headline = props.get('headline', 'No headline')
            area = props.get('areaDesc', 'Unknown area')
            message = f"NEW TSUNAMI ALERT\n\n{headline}\nAffected Area(s): {area}"

            for chat_id in user_subscriptions["tsunamis"]:
                 await context.bot.send_message(chat_id, message, parse_mode='HTML')
            if text_mentions_caribbean(area):
                for chat_id in user_subscriptions["caribbean"]:
                    await context.bot.send_message(chat_id, f"[CARIBBEAN REGION] {message}", parse_mode='HTML')


def main():
    """Start the bot."""
    if not TELEGRAM_BOT_TOKEN:
        logging.error("TELEGRAM_BOT_TOKEN environment variable not set!")
        return

    application = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()
    job_queue = application.job_queue

    # Add command handlers
    application.add_handler(CommandHandler('start', start))
    application.add_handler(CommandHandler('earthquakes', get_earthquakes))
    application.add_handler(CommandHandler('wildfires', get_wildfires))
    application.add_handler(CommandHandler('storms', get_storms))
    application.add_handler(CommandHandler('volcanoes', get_volcanoes))
    application.add_handler(CommandHandler('tsunamis', get_tsunamis))
    application.add_handler(CommandHandler('caribbean', get_caribbean_summary))

    application.add_handler(CommandHandler('subscribe', subscribe))
    application.add_handler(CommandHandler('unsubscribe', unsubscribe))
    application.add_handler(CallbackQueryHandler(button_callback))

    job_queue.run_repeating(check_for_alerts, interval=600, first=10)

    # Set the webhook
    # The WEBHOOK_URL is another environment variable we will set on the hosting platform.
    webhook_url = os.environ.get('WEBHOOK_URL')
    if webhook_url:
        print(f"Starting bot in webhook mode. URL: {webhook_url}")
        application.run_webhook(
            listen="0.0.0.0",
            port=PORT,
            url_path=TELEGRAM_BOT_TOKEN,
            webhook_url=f"{webhook_url}/{TELEGRAM_BOT_TOKEN}"
        )
    else:
        print("Starting bot in polling mode for local testing.")
        application.run_polling()


if __name__ == '__main__':
    main()